 var webVitals = (function (exports) {
        "use strict";

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        let bfcacheRestoreTime = -1;
        const getBFCacheRestoreTime = () => bfcacheRestoreTime;
        const onBFCacheRestore = (cb) => {
          addEventListener(
            "pageshow",
            (event) => {
              if (event.persisted) {
                bfcacheRestoreTime = event.timeStamp;
                cb(event);
              }
            },
            true
          );
        };

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const getRating = (value, thresholds) => {
          if (value > thresholds[1]) {
            return "poor";
          }
          if (value > thresholds[0]) {
            return "needs-improvement";
          }
          return "good";
        };
        const bindReporter = (
          callback,
          metric,
          thresholds,
          reportAllChanges
        ) => {
          // console.log(67);
          let prevValue;
          let delta;
          return (forceReport) => {
            if (metric.value >= 0) {
              console.log(81, reportAllChanges, prevValue)
              if (forceReport || reportAllChanges) {
                delta = metric.value - (prevValue ?? 0);
                console.log(82, delta, prevValue)
                // Report the metric if there's a non-zero delta or if no previous
                // value exists (which can happen in the case of the document becoming
                // hidden when the metric value is 0).
                // See: https://github.com/GoogleChrome/web-vitals/issues/14
                if (delta || prevValue === undefined) {
                  prevValue = metric.value;
                  metric.delta = delta;
                  metric.rating = getRating(metric.value, thresholds);
                  callback(metric);
                }
              }
            }
          };
        };

        /*
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const doubleRAF = (cb) => {
          requestAnimationFrame(() => requestAnimationFrame(() => cb()));
        };

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Performantly generate a unique, 30-char string by combining a version
         * number, the current timestamp with a 13-digit number integer.
         * @return {string}
         */
        const generateUniqueID = () => {
          return `v5-${Date.now()}-${
            Math.floor(Math.random() * (9e12 - 1)) + 1e12
          }`;
        };

        /*
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const getNavigationEntry = () => {
          const navigationEntry = performance.getEntriesByType("navigation")[0];
          // Check to ensure the `responseStart` property is present and valid.
          // In some cases a zero value is reported by the browser (for
          // privacy/security reasons), and in other cases (bugs) the value is
          // negative or is larger than the current page time. Ignore these cases:
          // - https://github.com/GoogleChrome/web-vitals/issues/137
          // - https://github.com/GoogleChrome/web-vitals/issues/162
          // - https://github.com/GoogleChrome/web-vitals/issues/275
          if (
            navigationEntry &&
            navigationEntry.responseStart > 0 &&
            navigationEntry.responseStart < performance.now()
          ) {
            return navigationEntry;
          }
        };

        /*
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const getActivationStart = () => {
          const navEntry = getNavigationEntry();
          return navEntry?.activationStart ?? 0;
        };

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const initMetric = (name, value = -1) => {
          const navEntry = getNavigationEntry();
          let navigationType = "navigate";
          if (getBFCacheRestoreTime() >= 0) {
            navigationType = "back-forward-cache";
          } else if (navEntry) {
            if (document.prerendering || getActivationStart() > 0) {
              navigationType = "prerender";
            } else if (document.wasDiscarded) {
              navigationType = "restore";
            } else if (navEntry.type) {
              navigationType = navEntry.type.replace(/_/g, "-");
            }
          }
          // Use `entries` type specific for the metric.
          const entries = [];
          return {
            name,
            value,
            rating: "good",
            // If needed, will be updated when reported. `const` to keep the type from widening to `string`.
            delta: 0,
            entries,
            id: generateUniqueID(),
            navigationType,
          };
        };

        /*
         * Copyright 2024 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const instanceMap = new WeakMap();
        /**
         * A function that accepts and identity object and a class object and returns
         * either a new instance of that class or an existing instance, if the
         * identity object was previously used.
         */
        function initUnique(identityObj, ClassObj) {
          if (!instanceMap.get(identityObj)) {
            instanceMap.set(identityObj, new ClassObj());
          }
          return instanceMap.get(identityObj);
        }

        /*
         * Copyright 2024 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        class LayoutShiftManager {
          constructor() {
            console.log(285);
          }
          _onAfterProcessingUnexpectedShift;
          _sessionValue = 0;
          _sessionEntries = [];
          _processEntry(entry) {
            // Only count layout shifts without recent user input.
            if (entry.hadRecentInput) return;
            const firstSessionEntry = this._sessionEntries[0];
            const lastSessionEntry = this._sessionEntries.at(-1);
            // If the entry occurred less than 1 second after the previous entry
            // and less than 5 seconds after the first entry in the session,
            // include the entry in the current session. Otherwise, start a new
            // session.
            if (
              this._sessionValue &&
              firstSessionEntry &&
              lastSessionEntry &&
              entry.startTime - lastSessionEntry.startTime < 1000 &&
              entry.startTime - firstSessionEntry.startTime < 5000
            ) {
              this._sessionValue += entry.value;
              this._sessionEntries.push(entry);
            } else {
              this._sessionValue = entry.value;
              this._sessionEntries = [entry];
            }
            this._onAfterProcessingUnexpectedShift?.(entry);
          }

          _resetSessionEntries() {
            console.log(312);
            this._sessionValue = 0;
            this._sessionEntries = [];
          }
        }

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Takes a performance entry type and a callback function, and creates a
         * `PerformanceObserver` instance that will observe the specified entry type
         * with buffering enabled and call the callback _for each entry_.
         *
         * This function also feature-detects entry support and wraps the logic in a
         * try/catch to avoid errors in unsupporting browsers.
         */
        const observe = (type, callback, opts = {}) => {
          try {
            if (PerformanceObserver.supportedEntryTypes.includes(type)) {
              const po = new PerformanceObserver((list) => {
                // Delay by a microtask to workaround a bug in Safari where the
                // callback is invoked immediately, rather than in a separate task.
                // See: https://github.com/GoogleChrome/web-vitals/issues/277
                Promise.resolve().then(() => {
                  callback(list.getEntries());
                });
              });
              po.observe({
                type,
                buffered: true,
                ...opts,
              });
              // po.
              return po;
            }
          } catch {
            // Do nothing.
          }
          return;
        };

        /*
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const runOnce = (cb) => {
          let called = false;
          return () => {
            if (!called) {
              cb();
              called = true;
            }
          };
        };

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        let firstHiddenTime = -1;
        const onHiddenFunctions = new Set();
        const initHiddenTime = () => {
          // If the document is hidden when this code runs, assume it was always
          // hidden and the page was loaded in the background, with the one exception
          // that visibility state is always 'hidden' during prerendering, so we have
          // to ignore that case until prerendering finishes (see: `prerenderingchange`
          // event logic below).
          return document.visibilityState === "hidden" && !document.prerendering
            ? 0
            : Infinity;
        };
        const onVisibilityUpdate = (event) => {
          // Handle changes to hidden state
          if (document.visibilityState === "hidden") {
            if (event.type === "visibilitychange") {
              for (const onHiddenFunction of onHiddenFunctions) {
                onHiddenFunction();
              }
            }
            // If the document is 'hidden' and no previous hidden timestamp has been
            // set (so is infinity), update it based on the current event data.
            if (!isFinite(firstHiddenTime)) {
              // If the event is a 'visibilitychange' event, it means the page was
              // visible prior to this change, so the event timestamp is the first
              // hidden time.
              // However, if the event is not a 'visibilitychange' event, then it must
              // be a 'prerenderingchange' event, and the fact that the document is
              // still 'hidden' from the above check means the tab was activated
              // in a background state and so has always been hidden.
              firstHiddenTime =
                event.type === "visibilitychange" ? event.timeStamp : 0;
              // We no longer need the `prerenderingchange` event listener now we've
              // set an initial init time so remove that
              // (we'll keep the visibilitychange one for onHiddenFunction above)
              removeEventListener(
                "prerenderingchange",
                onVisibilityUpdate,
                true
              );
            }
          }
        };
        const getVisibilityWatcher = () => {
          if (firstHiddenTime < 0) {
            // Check if we have a previous hidden `visibility-state` performance entry.
            const activationStart = getActivationStart();
            /* eslint-disable indent */
            const firstVisibilityStateHiddenTime = !document.prerendering
              ? globalThis.performance
                  .getEntriesByType("visibility-state")
                  .find(
                    (e) => e.name === "hidden" && e.startTime > activationStart
                  )?.startTime
              : undefined;
            /* eslint-enable indent */
            // Prefer that, but if it's not available and the document is hidden when
            // this code runs, assume it was hidden since navigation start. This isn't
            // a perfect heuristic, but it's the best we can do until the
            // `visibility-state` performance entry becomes available in all browsers.
            firstHiddenTime =
              firstVisibilityStateHiddenTime ?? initHiddenTime();
            // Listen for visibility changes so we can handle things like bfcache
            // restores and/or prerender without having to examine individual
            // timestamps in detail and also for onHidden function calls.
            addEventListener("visibilitychange", onVisibilityUpdate, true);
            // IMPORTANT: when a page is prerendering, its `visibilityState` is
            // 'hidden', so in order to account for cases where this module checks for
            // visibility during prerendering, an additional check after prerendering
            // completes is also required.
            addEventListener("prerenderingchange", onVisibilityUpdate, true);
            // Reset the time on bfcache restores.
            onBFCacheRestore(() => {
              // Schedule a task in order to track the `visibilityState` once it's
              // had an opportunity to change to visible in all browsers.
              // https://bugs.chromium.org/p/chromium/issues/detail?id=1133363
              setTimeout(() => {
                firstHiddenTime = initHiddenTime();
              });
            });
          }
          return {
            get firstHiddenTime() {
              return firstHiddenTime;
            },
            onHidden(cb) {
              onHiddenFunctions.add(cb);
            },
          };
        };

        /*
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        const whenActivated = (callback) => {
          if (document.prerendering) {
            addEventListener("prerenderingchange", () => callback(), true);
          } else {
            callback();
          }
        };

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /** Thresholds for FCP. See https://web.dev/articles/fcp#what_is_a_good_fcp_score */
        const FCPThresholds = [1800, 3000];
        /**
         * Calculates the [FCP](https://web.dev/articles/fcp) value for the current page and
         * calls the `callback` function once the value is ready, along with the
         * relevant `paint` performance entry used to determine the value. The reported
         * value is a `DOMHighResTimeStamp`.
         */
        const onFCP = (onReport, opts = {}) => {
          whenActivated(() => {
            const visibilityWatcher = getVisibilityWatcher();
            let metric = initMetric("FCP");
            let report;
            const handleEntries = (entries) => {
              for (const entry of entries) {
                if (entry.name === "first-contentful-paint") {
                  po.disconnect();
                  // Only report if the page wasn't hidden prior to the first paint.
                  if (entry.startTime < visibilityWatcher.firstHiddenTime) {
                    // The activationStart reference is used because FCP should be
                    // relative to page activation rather than navigation start if the
                    // page was prerendered. But in cases where `activationStart` occurs
                    // after the FCP, this time should be clamped at 0.
                    metric.value = Math.max(
                      entry.startTime - getActivationStart(),
                      0
                    );
                    metric.entries.push(entry);
                    report(true);
                  }
                }
              }
            };
            const po = observe("paint", handleEntries);
            if (po) {
              report = bindReporter(
                onReport,
                metric,
                FCPThresholds,
                opts.reportAllChanges
              );
              // Only report after a bfcache restore if the `PerformanceObserver`
              // successfully registered or the `paint` entry exists.
              onBFCacheRestore((event) => {
                metric = initMetric("FCP");
                report = bindReporter(
                  onReport,
                  metric,
                  FCPThresholds,
                  opts.reportAllChanges
                );
                doubleRAF(() => {
                  metric.value = performance.now() - event.timeStamp;
                  report(true);
                });
              });
            }
          });
        };

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /** Thresholds for CLS. See https://web.dev/articles/cls#what_is_a_good_cls_score */
        const CLSThresholds = [0.1, 0.25];
        /**
         * Calculates the [CLS](https://web.dev/articles/cls) value for the current page and
         * calls the `callback` function once the value is ready to be reported, along
         * with all `layout-shift` performance entries that were used in the metric
         * value calculation. The reported value is a `double` (corresponding to a
         * [layout shift score](https://web.dev/articles/cls#layout_shift_score)).
         *
         * If the `reportAllChanges` configuration option is set to `true`, the
         * `callback` function will be called as soon as the value is initially
         * determined as well as any time the value changes throughout the page
         * lifespan.
         *
         * _**Important:** CLS should be continually monitored for changes throughout
         * the entire lifespan of a page—including if the user returns to the page after
         * it's been hidden/backgrounded. However, since browsers often [will not fire
         * additional callbacks once the user has backgrounded a
         * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),
         * `callback` is always called when the page's visibility state changes to
         * hidden. As a result, the `callback` function might be called multiple times
         * during the same page load._
         */
        const onCLS = (onReport, opts = {}) => {
          const visibilityWatcher = getVisibilityWatcher();
          // Start monitoring FCP so we can only report CLS if FCP is also reported.
          // Note: this is done to match the current behavior of CrUX.
          onFCP(
            runOnce(() => {
              console.log(632);
              let metric = initMetric("CLS", 0);
              let report;
              const layoutShiftManager = initUnique(opts, LayoutShiftManager);
              const handleEntries = (entries) => {
                // layoutShiftManager._resetSessionEntries();


                for (const entry of entries) {
                  layoutShiftManager._processEntry(entry);
                }
                // If the current session value is larger than the current CLS value,
                // update CLS and the entries contributing to it.
                console.log(641, metric.value, layoutShiftManager._sessionValue);
                // if (layoutShiftManager._sessionValue) {
                // if (layoutShiftManager._sessionValue > metric.value) {
                  console.log(654)
                  metric.value = layoutShiftManager._sessionValue;
                  metric.entries = layoutShiftManager._sessionEntries;
                  report(true);
                // }
              };
              const po = observe("layout-shift", handleEntries);
              console.log(po)
              if (po) {
                console.log(674);
                report = bindReporter(
                  onReport,
                  metric,
                  CLSThresholds,
                  opts.reportAllChanges
                );
                visibilityWatcher.onHidden(() => {
                  console.log(661);
                  handleEntries(po.takeRecords());
                  report();
                });
                // Only report after a bfcache restore if the `PerformanceObserver`
                // successfully registered.
                onBFCacheRestore(() => {
                  console.log(668);
                  layoutShiftManager._sessionValue = 0;
                  metric = initMetric("CLS", 0);
                  report = bindReporter(
                    onReport,
                    metric,
                    CLSThresholds,
                    opts.reportAllChanges
                  );
                  doubleRAF(() => report());
                });
                // Queue a task to report (if nothing else triggers a report first).
                // This allows CLS to be reported as soon as FCP fires when
                // `reportAllChanges` is true.
                setTimeout(report);
              }
            })
          );
        };

        /*
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        let interactionCountEstimate = 0;
        let minKnownInteractionId = Infinity;
        let maxKnownInteractionId = 0;
        const updateEstimate = (entries) => {
          for (const entry of entries) {
            if (entry.interactionId) {
              minKnownInteractionId = Math.min(
                minKnownInteractionId,
                entry.interactionId
              );
              maxKnownInteractionId = Math.max(
                maxKnownInteractionId,
                entry.interactionId
              );
              interactionCountEstimate = maxKnownInteractionId
                ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1
                : 0;
            }
          }
        };
        let po;
        /**
         * Returns the `interactionCount` value using the native API (if available)
         * or the polyfill estimate in this module.
         */
        const getInteractionCount = () => {
          return po
            ? interactionCountEstimate
            : performance.interactionCount ?? 0;
        };
        /**
         * Feature detects native support or initializes the polyfill if needed.
         */
        const initInteractionCountPolyfill = () => {
          if ("interactionCount" in performance || po) return;
          po = observe("event", updateEstimate, {
            type: "event",
            buffered: true,
            durationThreshold: 0,
          });
        };

        /*
         * Copyright 2024 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        // To prevent unnecessary memory usage on pages with lots of interactions,
        // store at most 10 of the longest interactions to consider as INP candidates.
        const MAX_INTERACTIONS_TO_CONSIDER = 10;
        // Used to store the interaction count after a bfcache restore, since p98
        // interaction latencies should only consider the current navigation.
        let prevInteractionCount = 0;
        /**
         * Returns the interaction count since the last bfcache restore (or for the
         * full page lifecycle if there were no bfcache restores).
         */
        const getInteractionCountForNavigation = () => {
          return getInteractionCount() - prevInteractionCount;
        };
        class InteractionManager {
          /**
           * A list of longest interactions on the page (by latency) sorted so the
           * longest one is first. The list is at most MAX_INTERACTIONS_TO_CONSIDER
           * long.
           */
          _longestInteractionList = [];
          /**
           * A mapping of longest interactions by their interaction ID.
           * This is used for faster lookup.
           */
          _longestInteractionMap = new Map();
          _onBeforeProcessingEntry;
          _onAfterProcessingINPCandidate;
          _resetInteractions() {
            prevInteractionCount = getInteractionCount();
            this._longestInteractionList.length = 0;
            this._longestInteractionMap.clear();
          }
          /**
           * Returns the estimated p98 longest interaction based on the stored
           * interaction candidates and the interaction count for the current page.
           */
          _estimateP98LongestInteraction() {
            const candidateInteractionIndex = Math.min(
              this._longestInteractionList.length - 1,
              Math.floor(getInteractionCountForNavigation() / 50)
            );
            return this._longestInteractionList[candidateInteractionIndex];
          }
          /**
           * Takes a performance entry and adds it to the list of worst interactions
           * if its duration is long enough to make it among the worst. If the
           * entry is part of an existing interaction, it is merged and the latency
           * and entries list is updated as needed.
           */
          _processEntry(entry) {
            // console.log(803, entry)
            this._onBeforeProcessingEntry?.(entry);
            // Skip further processing for entries that cannot be INP candidates.
            if (!(entry.interactionId || entry.entryType === "first-input"))
              return;
            // The least-long of the 10 longest interactions.
            const minLongestInteraction = this._longestInteractionList.at(-1);
            let interaction = this._longestInteractionMap.get(
              entry.interactionId
            );
            // Only process the entry if it's possibly one of the ten longest,
            // or if it's part of an existing interaction.
            if (
              interaction ||
              this._longestInteractionList.length <
                MAX_INTERACTIONS_TO_CONSIDER ||
              // If the above conditions are false, `minLongestInteraction` will be set.
              entry.duration > minLongestInteraction._latency
            ) {
              // If the interaction already exists, update it. Otherwise create one.
              if (interaction) {
                // If the new entry has a longer duration, replace the old entries,
                // otherwise add to the array.
                if (entry.duration > interaction._latency) {
                  interaction.entries = [entry];
                  interaction._latency = entry.duration;
                } else if (
                  entry.duration === interaction._latency &&
                  entry.startTime === interaction.entries[0].startTime
                ) {
                  interaction.entries.push(entry);
                }
              } else {
                interaction = {
                  id: entry.interactionId,
                  entries: [entry],
                  _latency: entry.duration,
                };
                this._longestInteractionMap.set(interaction.id, interaction);
                this._longestInteractionList.push(interaction);
              }
              // Sort the entries by latency (descending) and keep only the top ten.
              this._longestInteractionList.sort(
                (a, b) => b._latency - a._latency
              );
              if (
                this._longestInteractionList.length >
                MAX_INTERACTIONS_TO_CONSIDER
              ) {
                const removedInteractions = this._longestInteractionList.splice(
                  MAX_INTERACTIONS_TO_CONSIDER
                );
                for (const interaction of removedInteractions) {
                  this._longestInteractionMap.delete(interaction.id);
                }
              }
              // Call any post-processing on the interaction
              this._onAfterProcessingINPCandidate?.(interaction);
            }
          }
        }

        /*
         * Copyright 2024 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Runs the passed callback during the next idle period, or immediately
         * if the browser's visibility state is (or becomes) hidden.
         */
        const whenIdleOrHidden = (cb) => {
          const rIC = globalThis.requestIdleCallback || setTimeout;
          // If the document is hidden, run the callback immediately, otherwise
          // race an idle callback with the next `visibilitychange` event.
          if (document.visibilityState === "hidden") {
            cb();
          } else {
            cb = runOnce(cb);
            addEventListener("visibilitychange", cb, {
              once: true,
              capture: true,
            });
            rIC(() => {
              cb();
              // Remove the above event listener since no longer required.
              // See: https://github.com/GoogleChrome/web-vitals/issues/622
              removeEventListener("visibilitychange", cb, {
                capture: true,
              });
            });
          }
        };

        /*
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /** Thresholds for INP. See https://web.dev/articles/inp#what_is_a_good_inp_score */
        const INPThresholds = [200, 500];
        // The default `durationThreshold` used across this library for observing
        // `event` entries via PerformanceObserver.
        const DEFAULT_DURATION_THRESHOLD = 40;
        /**
         * Calculates the [INP](https://web.dev/articles/inp) value for the current
         * page and calls the `callback` function once the value is ready, along with
         * the `event` performance entries reported for that interaction. The reported
         * value is a `DOMHighResTimeStamp`.
         *
         * A custom `durationThreshold` configuration option can optionally be passed
         * to control what `event-timing` entries are considered for INP reporting. The
         * default threshold is `40`, which means INP scores of less than 40 will not
         * be reported. To avoid reporting no interactions in these cases, the library
         * will fall back to the input delay of the first interaction. Note that this
         * will not affect your 75th percentile INP value unless that value is also
         * less than 40 (well below the recommended
         * [good](https://web.dev/articles/inp#what_is_a_good_inp_score) threshold).
         *
         * If the `reportAllChanges` configuration option is set to `true`, the
         * `callback` function will be called as soon as the value is initially
         * determined as well as any time the value changes throughout the page
         * lifespan.
         *
         * _**Important:** INP should be continually monitored for changes throughout
         * the entire lifespan of a page—including if the user returns to the page after
         * it's been hidden/backgrounded. However, since browsers often [will not fire
         * additional callbacks once the user has backgrounded a
         * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),
         * `callback` is always called when the page's visibility state changes to
         * hidden. As a result, the `callback` function might be called multiple times
         * during the same page load._
         */
        const onINP = (onReport, opts = {}) => {
          // Return if the browser doesn't support all APIs needed to measure INP.
          if (
            !(
              globalThis.PerformanceEventTiming &&
              "interactionId" in PerformanceEventTiming.prototype
            )
          ) {
            return;
          }
          const visibilityWatcher = getVisibilityWatcher();
          whenActivated(() => {
            // TODO(philipwalton): remove once the polyfill is no longer needed.
            initInteractionCountPolyfill();
            let metric = initMetric("INP");
            let report;
            const interactionManager = initUnique(opts, InteractionManager);
            const handleEntries = (entries) => {
              // console.log(973);
              // Queue the `handleEntries()` callback in the next idle task.
              // This is needed to increase the chances that all event entries that
              // occurred between the user interaction and the next paint
              // have been dispatched. Note: there is currently an experiment
              // running in Chrome (EventTimingKeypressAndCompositionInteractionId)
              // 123+ that if rolled out fully may make this no longer necessary.
              whenIdleOrHidden(() => {
                for (const entry of entries) {
                  // 802
                  interactionManager._processEntry(entry);
                }
                const inp = interactionManager._estimateP98LongestInteraction();
                // console.log(981, inp);
                if (inp && inp._latency !== metric.value) {
                  metric.value = inp._latency;
                  metric.entries = inp.entries;
                  report();

                  interactionManager._resetInteractions();
                }
              });
            };
            const po = observe("event", handleEntries, {
              // Event Timing entries have their durations rounded to the nearest 8ms,
              // so a duration of 40ms would be any event that spans 2.5 or more frames
              // at 60Hz. This threshold is chosen to strike a balance between usefulness
              // and performance. Running this callback for any interaction that spans
              // just one or two frames is likely not worth the insight that could be
              // gained.
              durationThreshold:
                opts.durationThreshold ?? DEFAULT_DURATION_THRESHOLD,
            });
            report = bindReporter(
              onReport,
              metric,
              INPThresholds,
              opts.reportAllChanges
            );
            // console.log(906);
            if (po) {
              // Also observe entries of type `first-input`. This is useful in cases
              // where the first interaction is less than the `durationThreshold`.
              po.observe({
                type: "first-input",
                buffered: true,
              });
              visibilityWatcher.onHidden(() => {
                // console.log(914);
                handleEntries(po.takeRecords());
                report(true);
              });
              // Only report after a bfcache restore if the `PerformanceObserver`
              // successfully registered.
              onBFCacheRestore(() => {
                // console.log(920);
                interactionManager._resetInteractions();
                metric = initMetric("INP");
                report = bindReporter(
                  onReport,
                  metric,
                  INPThresholds,
                  opts.reportAllChanges
                );
              });
            }
          });
        };

        /*
         * Copyright 2024 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        class LCPEntryManager {
          _onBeforeProcessingEntry;
          _processEntry(entry) {
            this._onBeforeProcessingEntry?.(entry);
          }
        }

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /** Thresholds for LCP. See https://web.dev/articles/lcp#what_is_a_good_lcp_score */
        const LCPThresholds = [2500, 4000];
        /**
         * Calculates the [LCP](https://web.dev/articles/lcp) value for the current page and
         * calls the `callback` function once the value is ready (along with the
         * relevant `largest-contentful-paint` performance entry used to determine the
         * value). The reported value is a `DOMHighResTimeStamp`.
         *
         * If the `reportAllChanges` configuration option is set to `true`, the
         * `callback` function will be called any time a new `largest-contentful-paint`
         * performance entry is dispatched, or once the final value of the metric has
         * been determined.
         */
        const onLCP = (onReport, opts = {}) => {
          whenActivated(() => {
            const visibilityWatcher = getVisibilityWatcher();
            let metric = initMetric("LCP");
            let report;
            const lcpEntryManager = initUnique(opts, LCPEntryManager);
            const handleEntries = (entries) => {
              // If reportAllChanges is set then call this function for each entry,
              // otherwise only consider the last one.
              if (!opts.reportAllChanges) {
                entries = entries.slice(-1);
              }
              for (const entry of entries) {
                lcpEntryManager._processEntry(entry);
                // Only report if the page wasn't hidden prior to LCP.
                if (entry.startTime < visibilityWatcher.firstHiddenTime) {
                  // The startTime attribute returns the value of the renderTime if it is
                  // not 0, and the value of the loadTime otherwise. The activationStart
                  // reference is used because LCP should be relative to page activation
                  // rather than navigation start if the page was prerendered. But in cases
                  // where `activationStart` occurs after the LCP, this time should be
                  // clamped at 0.
                  metric.value = Math.max(
                    entry.startTime - getActivationStart(),
                    0
                  );
                  metric.entries = [entry];
                  report();
                }
              }
            };
            const po = observe("largest-contentful-paint", handleEntries);
            if (po) {
              report = bindReporter(
                onReport,
                metric,
                LCPThresholds,
                opts.reportAllChanges
              );
              // Ensure this logic only runs once, since it can be triggered from
              // any of three different event listeners below.
              const stopListening = runOnce(() => {
                handleEntries(po.takeRecords());
                po.disconnect();
                report(true);
              });
              // Need a separate wrapper to ensure the `runOnce` function above is
              // common for all three functions
              const stopListeningWrapper = (event) => {
                if (event.isTrusted) {
                  // Wrap the listener in an idle callback so it's run in a separate
                  // task to reduce potential INP impact.
                  // https://github.com/GoogleChrome/web-vitals/issues/383
                  whenIdleOrHidden(stopListening);
                  removeEventListener(event.type, stopListeningWrapper, {
                    capture: true,
                  });
                }
              };
              // Stop listening after input or visibilitychange.
              // Note: while scrolling is an input that stops LCP observation, it's
              // unreliable since it can be programmatically generated.
              // See: https://github.com/GoogleChrome/web-vitals/issues/75
              for (const type of ["keydown", "click", "visibilitychange"]) {
                addEventListener(type, stopListeningWrapper, {
                  capture: true,
                });
              }
              // Only report after a bfcache restore if the `PerformanceObserver`
              // successfully registered.
              onBFCacheRestore((event) => {
                metric = initMetric("LCP");
                report = bindReporter(
                  onReport,
                  metric,
                  LCPThresholds,
                  opts.reportAllChanges
                );
                doubleRAF(() => {
                  metric.value = performance.now() - event.timeStamp;
                  report(true);
                });
              });
            }
          });
        };

        /*
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     https://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /** Thresholds for TTFB. See https://web.dev/articles/ttfb#what_is_a_good_ttfb_score */
        const TTFBThresholds = [800, 1800];
        /**
         * Runs in the next task after the page is done loading and/or prerendering.
         * @param callback
         */
        const whenReady = (callback) => {
          if (document.prerendering) {
            whenActivated(() => whenReady(callback));
          } else if (document.readyState !== "complete") {
            addEventListener("load", () => whenReady(callback), true);
          } else {
            // Queue a task so the callback runs after `loadEventEnd`.
            setTimeout(callback);
          }
        };
        /**
         * Calculates the [TTFB](https://web.dev/articles/ttfb) value for the
         * current page and calls the `callback` function once the page has loaded,
         * along with the relevant `navigation` performance entry used to determine the
         * value. The reported value is a `DOMHighResTimeStamp`.
         *
         * Note, this function waits until after the page is loaded to call `callback`
         * in order to ensure all properties of the `navigation` entry are populated.
         * This is useful if you want to report on other metrics exposed by the
         * [Navigation Timing API](https://w3c.github.io/navigation-timing/). For
         * example, the TTFB metric starts from the page's [time
         * origin](https://www.w3.org/TR/hr-time-2/#sec-time-origin), which means it
         * includes time spent on DNS lookup, connection negotiation, network latency,
         * and server processing time.
         */
        const onTTFB = (onReport, opts = {}) => {
          let metric = initMetric("TTFB");
          let report = bindReporter(
            onReport,
            metric,
            TTFBThresholds,
            opts.reportAllChanges
          );
          whenReady(() => {
            const navigationEntry = getNavigationEntry();
            if (navigationEntry) {
              // The activationStart reference is used because TTFB should be
              // relative to page activation rather than navigation start if the
              // page was prerendered. But in cases where `activationStart` occurs
              // after the first byte is received, this time should be clamped at 0.
              metric.value = Math.max(
                navigationEntry.responseStart - getActivationStart(),
                0
              );
              metric.entries = [navigationEntry];
              report(true);
              // Only report TTFB after bfcache restores if a `navigation` entry
              // was reported for the initial load.
              onBFCacheRestore(() => {
                metric = initMetric("TTFB", 0);
                report = bindReporter(
                  onReport,
                  metric,
                  TTFBThresholds,
                  opts.reportAllChanges
                );
                report(true);
              });
            }
          });
        };

        exports.CLSThresholds = CLSThresholds;
        exports.FCPThresholds = FCPThresholds;
        exports.INPThresholds = INPThresholds;
        exports.LCPThresholds = LCPThresholds;
        exports.TTFBThresholds = TTFBThresholds;
        exports.onCLS = onCLS;
        exports.onFCP = onFCP;
        exports.onINP = onINP;
        exports.onLCP = onLCP;
        exports.onTTFB = onTTFB;

        return exports;
      })({});
    